<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn Agent Manager</title>
    <link rel="icon" href="/static/docs/images/favicon-32x32.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/renderjson@1.4.0/renderjson.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #0D1117;
            color: #c9d1d9;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            color: #f0f6fc;
            margin-bottom: 10px;
        }

        .status-bar {
            background: #238636;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status-bar.warning {
            background: #f59e0b;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px;
            background: #161b22;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .section {
            background: #161b22;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            position: relative;
        }

        .section h2 {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #f0f6fc;
        }

        /* Special styles for the kickoff section */
        .section.kickoff-section {
            padding: 16px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 8px;
        }

        label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #c9d1d9;
            font-size: 0.9rem;
        }

        input, select, textarea, button {
            width: 100%;
            padding: 8px;
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: #0D1117;
            color: #c9d1d9;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #58a6ff;
        }

        textarea {
            height: 60px;
            resize: vertical;
        }

        button {
            background: #238636;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #2ea043;
        }

        button.secondary {
            background: #21262d;
        }

        button.secondary:hover {
            background: #30363d;
        }

        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .compact-buttons button {
            padding: 6px 10px;
            font-size: 13px;
        }

        .filters {
            display: grid;
            grid-template-columns: 2fr 2fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .task {
            border: 2px solid #30363d;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .parent-task {
            border-color: #1f6feb;
        }

        .child-task {
            border-left: 3px solid #58a6ff;
            margin-left: 5px;
        }

        .pm-subtask {
            border-left: 3px solid #8b5cf6;
            margin-left: 5px;
        }

        .task-header {
            background: #161b22;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: background-color 0.2s ease;
        }

        .parent-task > .task-header {
            background: #1f2937;
        }

        .child-task > .task-header {
            background: #21262d;
            border-left: none;
        }

        .pm-subtask > .task-header {
            background: #282a36;
            border-left: none;
        }

        .task-header:hover {
            background: #21262d;
        }

        .task-header-content {
            flex: 1;
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            transition: background-color 0.2s ease, color 0.2s ease;
            flex-shrink: 0;
            margin-left: 12px;
        }

        .delete-task-btn {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            background-color: #3c1c1e;
            color: #f85149;
            border: 1px solid #f85149;
            cursor: pointer;
            margin-left: 8px;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .delete-task-btn:hover {
            background-color: #4c2c2e;
        }

        .delete-task-btn svg {
            width: 12px;
            height: 12px;
            margin-right: 4px;
        }

        .task-content {
            display: none;
            padding: 20px;
            border-top: 1px solid #30363d;
            transition: all 0.3s ease;
        }

        .task-content.expanded {
            display: block;
        }

        .nested-tasks {
            margin-top: 15px;
            padding-left: 20px;
            border-left: 3px solid #30363d;
        }

        .has-children-indicator {
            font-size: 10px;
            background: #1f6feb;
            color: #f0f6fc;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            display: inline-block;
        }

        .subtask-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #1f2937;
            color: #9ca3af;
            margin-left: 8px;
        }

        .subtask-status.running {
            background: #1e40af;
            color: #93c5fd;
        }

        .subtask-status.completed {
            background: #065f46;
            color: #6ee7b7;
        }

        .mini-button {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #1f6feb;
            color: #f0f6fc;
            border: 1px solid #388bfd;
            cursor: pointer;
            margin-left: 5px;
            display: inline-block;
        }

        .mini-button:hover {
            background: #388bfd;
        }

        .run-all-subtasks {
            background: #1e40af !important;
        }

        .run-all-subtasks:hover {
            background: #1e3a8a !important;
        }

        .arrow-up-right:after {
            content: "↗";
            font-style: normal;
            font-size: 10px;
            vertical-align: top;
        }

        /* GitHub PR links styling */
        .pr-links-container {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .pr-link {
            display: inline-flex;
            align-items: center;
            background-color: #132f4c;
            color: #58a6ff;
            font-size: 11px;
            font-weight: 500;
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #1f6feb;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .pr-link:hover {
            background-color: #1f6feb;
            border-color: #388bfd;
            color: #f0f6fc;
        }

        .pr-link img {
            width: 12px;
            height: 12px;
            margin-right: 4px;
            vertical-align: middle;
            opacity: 0.85;
        }

        .pr-links-label {
            font-size: 11px;
            color: #8b949e;
            display: flex;
            align-items: center;
            margin-right: 2px;
        }

        /* Play button icon */
        .play-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background-color: #238636;
            color: white;
            border-radius: 50%;
            margin-right: 12px;
        }

        .play-icon::before {
            content: "";
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid white;
            margin-left: 2px; /* Slight offset to center the triangle */
        }

        .section-heading {
            display: flex;
            align-items: center;
        }

        .task-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .status-completed { background: #132e1f; color: #56d364; }
        .status-failed { background: #3c1c1e; color: #f85149; }
        .status-running { background: #3b2e00; color: #e3b341; }
        .status-queued { background: #21262d; color: #8b949e; }

        .debug-section {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .debug-message {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            margin-bottom: 5px;
            color: #8b949e;
            transition: opacity 0.2s ease;
        }

        .task-count {
            font-weight: 500;
            color: #8b949e;
            position: absolute;
            top: 25px;
            right: 25px;
            margin: 0;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .no-tasks-message {
            color: #8b949e;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-container input[type="checkbox"] {
            width: auto;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideIn 0.3s ease-out;
        }

        .alert-success {
            background: #132e1f;
            border: 1px solid #238636;
            color: #56d364;
        }

        .alert-error {
            background: #3c1c1e;
            border: 1px solid #f85149;
            color: #f85149;
        }

        .alert-warning {
            background: #3b2e00;
            border: 1px solid #f59e0b;
            color: #fcd34d;
        }

        .alert-close {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
            font-size: 18px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .alert-close:hover {
            opacity: 1;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(-20px);
                opacity: 0;
            }
        }

        /* Log Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: #0D1117;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #30363d;
            width: 80%;
            max-width: 900px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #30363d;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            color: #f0f6fc;
        }

        .close-button {
            color: #8b949e;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .log-container {
            background: #161b22;
            color: #c9d1d9;
            font-family: 'Monaco', 'Consolas', monospace;
            padding: 15px;
            border-radius: 8px;
            height: 60vh;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Renderjson styling */
        .renderjson {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
        }

        .renderjson .disclosure {
            color: #58a6ff;
            font-weight: bold;
            cursor: pointer;
        }

        .renderjson .string {
            color: #7ee787;
        }

        .renderjson .number {
            color: #f0883e;
        }

        .renderjson .boolean {
            color: #ff7b72;
        }

        .renderjson .key {
            color: #d2a8ff;
            font-weight: 600;
        }

        .renderjson .null {
            color: #8b949e;
        }

        /* Dark theme for logs */
        .log-container .renderjson .string {
            color: #7ee787;
        }

        .log-container .renderjson .number {
            color: #f0883e;
        }

        .log-container .renderjson .boolean {
            color: #ff7b72;
        }

        .log-container .renderjson .key {
            color: #d2a8ff;
        }

        .log-container .renderjson .null {
            color: #8b949e;
        }

        /* Subtask Card Styles */
        .subtask-cards {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .subtask-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.2s ease;
        }

        .subtask-card:hover {
            border-color: #58a6ff;
        }

        .subtask-card.created {
            border-color: #238636;
        }

        .subtask-card.running {
            border-color: #1e40af;
        }

        .subtask-card.completed {
            border-color: #065f46;
        }

        .subtask-card.queued {
            border-color: #78350f;
        }

        .subtask-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .subtask-header h4 {
            margin: 0;
            font-size: 14px;
            color: #f0f6fc;
        }

        .subtask-meta {
            display: flex;
            gap: 8px;
        }

        .subtask-meta span {
            background: #21262d;
            color: #8b949e;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .subtask-content {
            font-size: 12px;
            color: #c9d1d9;
            margin-bottom: 10px;
        }

        .subtask-actions {
            display: flex;
            justify-content: flex-end;
        }

        .subtask-actions button {
            background: #238636;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s ease;
        }

        .subtask-actions button:hover:not(:disabled) {
            background: #2ea043;
        }

        .subtask-actions button:disabled {
            background: #21262d;
            color: #8b949e;
            cursor: default;
        }

        .subtask-actions .running-subtask {
            background: #1e40af !important;
        }

        .subtask-actions .completed-subtask {
            background: #065f46 !important;
        }

        .all-subtasks-run {
            background: #374151 !important;
            color: #9ca3af !important;
            cursor: not-allowed !important;
        }

        .running-subtask {
            background: #1e40af !important;
            color: #93c5fd !important;
            cursor: not-allowed !important;
        }

        .completed-subtask {
            background: #065f46 !important;
            color: #6ee7b7 !important;
            cursor: not-allowed !important;
        }

        .queued-subtask {
            background: #78350f !important;
            color: #fcd34d !important;
            cursor: not-allowed !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <img src="/static/docs/images/cairn-logo.png" alt="Cairn Logo" class="logo" style="max-width: 300px; margin-bottom: -30px;">
            <p id="status-bar" class="hidden status-bar"></p>
        </div>

        <div id="alert-container"></div>

        <div class="section kickoff-section">
            <h2>🤖 Kickoff New Agent</h2>
            <div class="form-grid">
                <div class="form-group">
                    <label for="agent-type">Agent Type</label>
                    <select id="agent-type" onchange="updateRepoVisibility()"></select>
                </div>
                <div class="form-group">
                    <label for="description">Task Description</label>
                    <textarea id="description" placeholder="e.g., Implement a health check endpoint"></textarea>
                </div>
            </div>
            <div id="repo-fields">
                <!-- Repo fields will be dynamically inserted here -->
            </div>
            <div class="button-row compact-buttons">
                <button onclick="kickoffAgent()">🚀 Kickoff Agent</button>
                <button class="secondary" onclick="resetForm()">Clear</button>
            </div>
        </div>

        <div class="section">
            <h2 class="section-heading"><span class="play-icon"></span>Active Tasks</h2>
            <div id="tasks-container">
                <p id="tasks-loading-message">Loading tasks...</p>
            </div>
        </div>

        <div class="section">
            <h2>🐛 Recent Debug Messages</h2>
            <div id="debug-messages" class="debug-section"></div>
        </div>
    </div>

    <!-- Log Viewer Modal -->
    <div id="log-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h2 id="log-modal-title">Task Logs</h2>
                    <small id="log-last-updated" style="color: #6b7280; font-weight: normal;"></small>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="copy-logs-btn" style="padding: 5px 10px; font-size: 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">📋 Copy Logs</button>
                    <span class="close-button">&times;</span>
                </div>
            </div>
            <div id="log-container" class="log-container">
                <p>Loading logs...</p>
            </div>
        </div>
    </div>

    <script>
        // Move all declarations to the top level of the script
        const agentTypeSelect = document.getElementById('agent-type');
        const descriptionInput = document.getElementById('description');
        const repoFieldsContainer = document.getElementById('repo-fields');
        const tasksContainer = document.getElementById('tasks-container');
        const debugMessagesContainer = document.getElementById('debug-messages');
        const alertContainer = document.getElementById('alert-container');

        // Log Modal elements
        const logModal = document.getElementById('log-modal');
        const logModalTitle = document.getElementById('log-modal-title');
        const logContainer = document.getElementById('log-container');
        const logLastUpdated = document.getElementById('log-last-updated');
        const copyLogsBtn = document.getElementById('copy-logs-btn');
        const closeButton = document.querySelector('.close-button');

        let config = {};
        let activeTasks = [];
        let expandedTasks = new Set(); // Track expanded tasks
        let activeTimers = {
            tasks: null,
            debug: null,
            logs: null
        };

        let lastLogCount = 0; // Track number of logs already rendered
        let renderedLogIds = new Set(); // Track which logs have been rendered
        let currentLogRunId = null; // Track which task's logs we're currently viewing
        let lastRenderedLogId = null; // Track the last log we rendered

        function setLoading(isLoading) {
            document.body.classList.toggle('loading', isLoading);
        }

        function showAlert(message, type = 'success', duration = 5000) {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;

            // Create message container
            const messageContainer = document.createElement('div');
            messageContainer.textContent = message;
            alert.appendChild(messageContainer);

            // Create close button
            const closeButton = document.createElement('button');
            closeButton.className = 'alert-close';
            closeButton.innerHTML = '×';
            closeButton.onclick = () => {
                alert.style.animation = 'fadeOut 0.3s ease-out forwards';
                setTimeout(() => alert.remove(), 300);
            };
            alert.appendChild(closeButton);

            // Add to container
            alertContainer.appendChild(alert);

            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.style.animation = 'fadeOut 0.3s ease-out forwards';
                        setTimeout(() => alert.remove(), 300);
                    }
                }, duration);
            }
        }

        async function fetchConfig() {
            try {
                const response = await fetch('/config');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                config = await response.json();

                // Populate agent types
                agentTypeSelect.innerHTML = config.available_agent_types.map(type => `<option value="${type}">${type}</option>`).join('');
                updateRepoVisibility();

                // Update status bar
                const statusBar = document.getElementById('status-bar');
                statusBar.innerHTML = `<a href="/repos" style="color: inherit; text-decoration: none;">Repository Manager <span style="font-size: 0.9em; opacity: 0.8;">(${config.connected_repos.length} repos)</span></a>`;
                statusBar.classList.remove('hidden');
                statusBar.style.fontSize = '12px';
                statusBar.style.padding = '5px 10px';
                statusBar.style.position = 'absolute';
                statusBar.style.top = '10px';
                statusBar.style.right = '10px';
                statusBar.style.margin = '0';
                statusBar.style.borderRadius = '4px';
                statusBar.style.cursor = 'pointer';
            } catch (error) {
                showAlert(`Failed to load config: ${error.message}`, 'error');
                const statusBar = document.getElementById('status-bar');
                statusBar.textContent = '⚠️ API connection error';
                statusBar.classList.add('warning');
                statusBar.classList.remove('hidden');
                statusBar.style.fontSize = '12px';
                statusBar.style.padding = '5px 10px';
                statusBar.style.position = 'absolute';
                statusBar.style.top = '10px';
                statusBar.style.right = '10px';
                statusBar.style.margin = '0';
                statusBar.style.borderRadius = '4px';
            }
        }

        window.updateRepoVisibility = () => {
            const agentType = agentTypeSelect.value;
            const repos = config.connected_repos || [];
            let html = '';

            if (agentType === 'Fullstack Planner') {
                html = `
                    <div class="form-group">
                        <label for="repos">Repositories (multi-select)</label>
                        <div id="repos-container" style="margin-top: 8px;">
                            ${repos.map(repo => `
                                <span class="repo-option" data-repo="${repo}" onclick="toggleRepoSelection(this)" style="display: inline-block; padding: 4px 8px; margin: 0 8px 8px 0; cursor: pointer; border: 1px solid #30363d; border-radius: 4px; font-size: 12px; background: #0D1117; color: #c9d1d9;">
                                    ${repo}
                                </span>
                            `).join('')}
                        </div>
                        <input type="hidden" id="selected-repos" value="">
                    </div>
                `;
                repoFieldsContainer.innerHTML = html;
            } else if (agentType === 'PM' || agentType === 'SWE') {
                html = `
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="repo">Repository</label>
                            <select id="repo">
                                ${repos.map(repo => `<option value="${repo}">${repo}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="branch">Branch (optional)</label>
                            <input type="text" id="branch" placeholder="e.g., feature/new-login">
                        </div>
                    </div>
                `;
            }
            repoFieldsContainer.innerHTML = html;
        }

        window.resetForm = () => {
            descriptionInput.value = '';
            agentTypeSelect.selectedIndex = 0;
            updateRepoVisibility();
        }

        window.kickoffAgent = async () => {
            const agent_type = agentTypeSelect.value;
            const description = descriptionInput.value.trim();

            if (!description) {
                showAlert('Task description is required', 'error');
                return;
            }

            let payload = { description };
            if (agent_type === 'Fullstack Planner') {
                const selectedRepos = document.getElementById('selected-repos').value.split(',').filter(repo => repo);
                payload.repos = selectedRepos;
                if (payload.repos.length === 0) {
                    showAlert('At least one repository is required for Fullstack Planner', 'error');
                    return;
                }
            } else {
                payload.repo = document.getElementById('repo').value;
                payload.branch = document.getElementById('branch').value.trim() || null;
            }

            try {
                setLoading(true);
                const response = await fetch('/kickoff-agent', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ agent_type, payload })
                });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to start agent');
                }
                const result = await response.json();
                showAlert(`Agent started with Run ID: ${result.run_id}`);
                resetForm();
                fetchActiveTasks(); // immediate refresh
            } catch (error) {
                showAlert(`Error: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        function renderTasks() {
            if (activeTasks.length === 0) {
                tasksContainer.innerHTML = '<p class="no-tasks-message">No active tasks. Use the kickoff form above to start a new agent.</p>';
                return;
            }

            // Organize tasks by parent-child relationships
            const taskMap = {};
            const rootTasks = [];

            // First pass: Create a map of all tasks by their run_id/task_id
            activeTasks.forEach(task => {
                const taskId = (task.payload && task.payload.run_id) || task.task_id;
                taskMap[taskId] = {
                    task: task,
                    children: []
                };
            });

            // Second pass: Organize into parent-child hierarchy
            activeTasks.forEach(task => {
                const payload = task.payload || {};
                const parentRunId = payload.parent_run_id;
                const parentFullstackId = payload.parent_fullstack_id;

                // Check for parent_run_id first, then parent_fullstack_id
                if (parentRunId && taskMap[parentRunId]) {
                    // This is a child task with parent_run_id, add it to its parent's children array
                    taskMap[parentRunId].children.push(task);
                } else if (parentFullstackId && taskMap[parentFullstackId]) {
                    // This is a PM task with parent_fullstack_id, add it to its parent's children array
                    taskMap[parentFullstackId].children.push(task);
                } else {
                    // This is a root task (no parent or parent not found)
                    rootTasks.push(task);
                }
            });

            // Render the tasks hierarchy
            tasksContainer.innerHTML = `
                <p class="task-count">${activeTasks.length} active task${activeTasks.length !== 1 ? 's' : ''}</p>
                ${rootTasks.map(task => renderTask(task, taskMap)).join('')}
            `;

            // Restore expanded state for tasks
            expandedTasks.forEach(taskId => {
                const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskElement) {
                    const content = taskElement.querySelector('.task-content');
                    if (content) {
                        content.classList.add('expanded');
                    }
                }
            });

            // Render JSON payloads using renderjson
            activeTasks.forEach(task => {
                const payload = task.payload || {};
                const jsonViewerId = `json-viewer-${task.task_id}`;
                const container = document.getElementById(jsonViewerId);
                if (container) {
                    container.innerHTML = '';

                    // Configure renderjson settings
                    renderjson.set_icons('+', '-');
                    renderjson.set_show_to_level(10);

                    try {
                        const jsonElement = renderjson(payload);
                        jsonElement.style.cssText = 'background: #161b22; padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; font-family: Monaco, Consolas, monospace; font-size: 12px;';
                        container.appendChild(jsonElement);
                    } catch (error) {
                        console.warn('Renderjson error:', error);
                        // Simple fallback
                        const pre = document.createElement('pre');
                        pre.style.cssText = 'background: #161b22; padding: 10px; border-radius: 8px; max-height: 200px; overflow-y: auto; white-space: pre-wrap;';
                        pre.textContent = JSON.stringify(payload, null, 2);
                        container.appendChild(pre);
                    }
                }
            });
        }

        function renderTask(task, taskMap) {
            const payload = task.payload || {};
            const { run_id, agent_type, agent_status, description, parent_run_id, parent_fullstack_id } = payload;
            const statusClass = `status-${(agent_status || 'unknown').toLowerCase()}`;
            const taskId = run_id || task.task_id;
            const displayId = taskId;

            // Truncate description if longer than 200 characters
            const truncatedDesc = description && description.length > 200
                ? description.substring(0, 200) + '...'
                : description || 'No description.';
            const fullDesc = description || 'No description.';

            // Check if this is a completed Fullstack Planner with agent_output containing subtasks
            const isCompletedFullstack = agent_type === 'Fullstack Planner' && agent_status === 'Completed';
            const hasSubtasks = isCompletedFullstack && payload.agent_output &&
                               payload.agent_output.list_of_subtasks &&
                               payload.agent_output.list_of_subtasks.length > 0;

            // Create buttons HTML
            let buttonsHtml = `<button class="secondary" onclick="viewLogs('${taskId}', '${displayId}')">View Logs</button>`;

            // For child tasks, also show parent task ID in the logs button
            if (parent_run_id || parent_fullstack_id) {
                const parentId = parent_run_id || parent_fullstack_id;
                buttonsHtml = `<button class="secondary" onclick="viewLogs('${taskId}', '${displayId} (Child of ${parentId})')">View Logs</button>`;
            }

            if (hasSubtasks) {
                // Check if all subtasks have been run
                const childTasks = taskMap && taskMap[taskId] ? taskMap[taskId].children : [];
                const allSubtasksRun = childTasks.length > 0 && childTasks.every(child =>
                    child.payload &&
                    ['Completed', 'Running', 'Queued'].includes(child.payload.agent_status)
                );

                // Count how many subtasks are already running/completed/queued
                const runSubtasks = childTasks.filter(child =>
                    child.payload &&
                    ['Completed', 'Running', 'Queued'].includes(child.payload.agent_status)
                ).length;

                if (allSubtasksRun) {
                    buttonsHtml += `<button disabled class="all-subtasks-run">All PM Tasks Run</button>`;
                } else if (runSubtasks > 0) {
                    buttonsHtml += `<button onclick="createSubtasks('${taskId}')">🚀 Create Remaining PM Tasks (${runSubtasks}/${childTasks.length} run)</button>`;
                } else {
                    buttonsHtml += `<button onclick="createSubtasks('${taskId}')">🚀 Create All PM Tasks</button>`;
                }
            }

            // Check for child tasks
            const childTasks = taskMap && taskMap[taskId] ? taskMap[taskId].children : [];
            const hasChildren = childTasks.length > 0;

            // Check subtask creation status and running status for Fullstack Planner
            let subtaskStatus = '';
            let runAllSubtasksButton = '';

            if (agent_type === 'Fullstack Planner' && agent_status === 'Completed') {
                if (hasChildren) {
                    // Check if any child tasks are running
                    const runningChildren = childTasks.filter(child =>
                        child.payload && child.payload.agent_status === 'Running');

                    if (runningChildren.length > 0) {
                        subtaskStatus = `<span class="subtask-status running">⚙️ ${runningChildren.length}/${childTasks.length} subtasks running</span>`;
                    } else {
                        // Check if all children are completed
                        const completedChildren = childTasks.filter(child =>
                            child.payload && child.payload.agent_status === 'Completed');

                        // Only show running status or count - never show "All subtasks completed"
                        subtaskStatus = `<span class="subtask-status">${completedChildren.length}/${childTasks.length} subtasks completed</span>`;

                        // Add button to run all non-completed subtasks
                        if (completedChildren.length < childTasks.length) {
                            runAllSubtasksButton = `<button class="run-all-subtasks" onclick="event.stopPropagation(); runAllSubtasks('${taskId}')">▶️ Run All Subtasks</button>`;
                        }
                    }
                } else if (hasSubtasks) {
                    subtaskStatus = `<span class="subtask-status">Subtasks ready to create</span>`;
                }
            }

            // Render child tasks if present
            const childTasksHtml = hasChildren ? `
                <div class="nested-tasks">
                    ${childTasks.map(childTask => renderTask(childTask, taskMap)).join('')}
                </div>
            ` : '';

            // Determine if the task has a parent (either parent_run_id or parent_fullstack_id)
            const hasParent = parent_run_id || parent_fullstack_id;
            const parentId = parent_run_id || parent_fullstack_id;
            const parentType = parent_run_id ? 'Child of' : 'PM subtask of';

            // Choose the right CSS class based on the parent type
            let taskClass = '';
            if (hasChildren) {
                taskClass += 'parent-task ';
            }
            if (parent_run_id) {
                taskClass += 'child-task ';
            } else if (parent_fullstack_id) {
                taskClass += 'pm-subtask ';
            }

            // Only show the full description in expanded view if it differs from the truncated version
            const showFullDescription = description && description.length > 200;

            // Create PR links HTML
            let prLinksHtml = '';

            // For Fullstack Planner, collect PR URLs from PM children tasks
            if (agent_type === 'Fullstack Planner' && hasChildren) {
                const prLinks = [];

                // Loop through child tasks to collect PR URLs
                childTasks.forEach(childTask => {
                    const childPayload = childTask.payload || {};
                    const childAgentOutput = childPayload.agent_output || {};
                    const prUrl = childAgentOutput.pr_url;

                    if (prUrl) {
                        const childRepo = childPayload.repo || '';
                        prLinks.push({
                            url: prUrl,
                            repo: childRepo,
                            runId: childPayload.run_id || childTask.task_id
                        });
                    }
                });

                if (prLinks.length > 0) {
                    prLinksHtml = `
                        <div class="pr-links-container">
                            <span class="pr-links-label">PRs:</span>
                            ${prLinks.map(link =>
                                `<a href="${link.url}" target="_blank" class="pr-link">
                                    <img src="https://cdn-icons-png.flaticon.com/512/25/25231.png" alt="GitHub">
                                    ${link.repo}
                                </a>`
                            ).join('')}
                        </div>
                    `;
                }
            }
            // For PM tasks, check for PR URL in agent_output
            else if (agent_type === 'PM' && payload.agent_output && payload.agent_output.pr_url) {
                const prUrl = payload.agent_output.pr_url;
                const repo = payload.repo || '';

                prLinksHtml = `
                    <div class="pr-links-container">
                        <a href="${prUrl}" target="_blank" class="pr-link">
                            <img src="https://cdn-icons-png.flaticon.com/512/25/25231.png" alt="GitHub">
                            ${repo} PR
                        </a>
                    </div>
                `;
            }

            // Special handling for Fullstack Planner output
            let subtaskCardsHtml = '';
            if (isCompletedFullstack && payload.agent_output) {
                const subtasks = payload.agent_output.list_of_subtasks || [];
                const subtaskTitles = payload.agent_output.list_of_subtask_titles || [];
                const subtaskRepos = payload.agent_output.list_of_subtask_repos || [];
                const subtaskDifficulties = payload.agent_output.assessment_of_subtask_difficulty || [];
                const subtaskAssignments = payload.agent_output.assessment_of_subtask_assignment || [];

                // Check which subtasks have already been created
                const createdSubtasks = childTasks.map(child => {
                    const childPayload = child.payload || {};
                    return childPayload.subtask_index;
                });

                subtaskCardsHtml = `
                    <div class="subtask-cards">
                        ${subtasks.map((subtask, index) => {
                            const title = subtaskTitles[index] || `Subtask ${index + 1}`;
                            const repo = subtaskRepos[index] || '';
                            const difficulty = subtaskDifficulties[index] || 'Not specified';
                            const assignment = subtaskAssignments[index] || 'agent';
                            const isCreated = createdSubtasks.includes(index);
                            const isRunning = childTasks.some(child =>
                                child.payload &&
                                child.payload.subtask_index === index &&
                                child.payload.agent_status === 'Running'
                            );
                            const isCompleted = childTasks.some(child =>
                                child.payload &&
                                child.payload.subtask_index === index &&
                                child.payload.agent_status === 'Completed'
                            );
                            const isQueued = childTasks.some(child =>
                                child.payload &&
                                child.payload.subtask_index === index &&
                                child.payload.agent_status === 'Queued'
                            );

                            let buttonHtml = '';
                            if (isRunning) {
                                buttonHtml = `<button disabled class="running-subtask">⚙️ Running...</button>`;
                            } else if (isCompleted) {
                                buttonHtml = `<button disabled class="completed-subtask">✅ Run Complete</button>`;
                            } else if (isQueued) {
                                buttonHtml = `<button disabled class="queued-subtask">⏳ Queued</button>`;
                            } else if (!isCreated) {
                                buttonHtml = `<button onclick="event.stopPropagation(); createSingleSubtask('${taskId}', ${index})" class="create-subtask">Create ${assignment} Task</button>`;
                            } else {
                                buttonHtml = `<button onclick="event.stopPropagation(); runSingleSubtask('${taskId}', ${index})" class="run-subtask">▶️ Run ${assignment} Task</button>`;
                            }

                            return `
                                <div class="subtask-card ${isCreated ? 'created' : ''} ${isRunning ? 'running' : ''} ${isCompleted ? 'completed' : ''} ${isQueued ? 'queued' : ''}">
                                    <div class="subtask-header">
                                        <h4>${title}</h4>
                                        <div class="subtask-meta">
                                            <span class="difficulty">${difficulty}</span>
                                            <span class="assignee">${assignment}</span>
                                        </div>
                                    </div>
                                    <div class="subtask-content">
                                        <p>${subtask}</p>
                                    </div>
                                    <div class="subtask-actions">
                                        ${buttonHtml}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            return `
                <div class="task ${taskClass}" data-task-id="${task.task_id}">
                    <div class="task-header" onclick="toggleTask(this)">
                        <div class="task-header-content">
                            <strong>${taskId}</strong> ${hasChildren ? `<span class="has-children-indicator">${childTasks.length} subtask${childTasks.length > 1 ? 's' : ''}</span>` : ''} (${agent_type || 'Unknown'})
                            <p style="font-size: 12px; color: #6b7280;">${truncatedDesc}</p>
                            ${hasParent ? `<p style="font-size: 11px; color: #9ca3af;">↑ ${parentType} ${parentId}</p>` : ''}
                            ${prLinksHtml}
                            ${subtaskStatus}
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span class="status-badge ${statusClass}">${agent_status || 'UNKNOWN'}</span>
                            <button class="delete-task-btn" onclick="event.stopPropagation(); deleteTask('${taskId}', ${hasChildren})">
                                <span style="margin-right: 3px;">🗑️</span> Delete
                            </button>
                        </div>
                    </div>
                    <div class="task-content">
                        ${showFullDescription ? `<div style="margin-top: 10px;"><p style="font-size: 12px; color: #6b7280;">${fullDesc}</p></div>` : ''}
                        ${subtaskCardsHtml}
                        <div class="button-row" style="margin-top: 15px;">
                            ${buttonsHtml}
                            ${runAllSubtasksButton}
                        </div>
                        ${childTasksHtml}
                    </div>
                </div>
            `;
        }

        function renderDebugMessages(messages) {
            if (messages.length === 0) {
                debugMessagesContainer.innerHTML = '<p>No debug messages.</p>';
                return;
            }
            // Show latest messages first - don't reverse since API should return them in DESC order
            debugMessagesContainer.innerHTML = messages.map(renderDebugMessage).join('');
        }

        function renderDebugMessage(msg) {
            return `<div class="debug-message">${msg.message}</div>`;
        }

        async function fetchActiveTasks() {
            try {
                // Hide loading message after first load
                const loadingMessage = document.getElementById('tasks-loading-message');
                if (loadingMessage) {
                    loadingMessage.style.display = 'none';
                }

                const response = await fetch('/active-tasks');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const tasks = await response.json();
                // Basic check to see if data has changed to avoid unnecessary re-renders
                if (JSON.stringify(tasks) !== JSON.stringify(activeTasks)) {
                    activeTasks = tasks;
                    renderTasks();
                }
            } catch (error) {
                console.error('Failed to fetch active tasks:', error);
                tasksContainer.innerHTML = '<p>Error loading tasks. Please try refreshing the page.</p>';
            }
        }

        async function fetchDebugMessages() {
            try {
                const response = await fetch('/debug-messages?limit=20');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const messages = await response.json();
                renderDebugMessages(messages);
            } catch (error) {
                console.error('Failed to fetch debug messages:', error);
            }
        }

        async function fetchTaskLogs(runId) {
            try {
                console.log('Fetching logs for runId:', runId);
                // For child tasks, try both the task_id and run_id
                const response = await fetch(`/task-logs/${runId}`);
                if (!response.ok) {
                    console.error('Error response from server:', response.status, response.statusText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const logs = await response.json();
                console.log('Received logs:', logs);

                // Always render logs when we get new data
                renderLogs(logs);

                // Update the last updated timestamp in the modal header
                logLastUpdated.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            } catch (error) {
                console.error('Error fetching logs:', error);
                // Don't clear existing logs on error - just log to console
                // If there are no existing logs, show error message
                if (lastLogCount === 0) {
                    logContainer.innerHTML = `<p style="color: #fca5a5;">Error fetching logs: ${error.message}</p>`;
                }
            }
        }

        function renderLogs(logs) {
            console.log('Rendering logs, count:', logs.length);
            if (logs.length === 0) {
                logContainer.innerHTML = "<p>No logs found for this task yet.</p>";
                lastLogCount = 0;
                renderedLogIds.clear();
                return;
            }

            // Store current scroll position
            const scrollPosition = logContainer.scrollTop;

            // Clear and re-render all logs to ensure proper ordering
            logContainer.innerHTML = '';
            lastLogCount = 0;
            renderedLogIds.clear();

            const fragment = document.createDocumentFragment();

            logs.forEach(log => {
                console.log('Processing log entry:', log);
                let logData = log.log_data;
                try {
                    logData = JSON.parse(logData);
                } catch (e) {
                    console.log('Log data is not JSON, using as string');
                }

                const logEntry = document.createElement('div');

                const header = document.createElement('strong');
                header.textContent = `[${new Date(log.created_at).toLocaleString()}] ${log.agent_type}:`;
                logEntry.appendChild(header);

                if (typeof logData === 'object' && logData !== null) {
                    // Configure renderjson settings
                    renderjson.set_icons('+', '-');
                    renderjson.set_show_to_level(10); // Expand everything by default

                    try {
                        const jsonElement = renderjson(logData);
                        jsonElement.style.cssText = 'color: #e2e8f0; margin: 5px 0; font-family: Monaco, Consolas, monospace; font-size: 12px;';
                        logEntry.appendChild(document.createTextNode('\n'));
                        logEntry.appendChild(jsonElement);
                    } catch (error) {
                        console.warn('Renderjson error in logs:', error);
                        // Fallback to formatted text
                        const textContent = document.createElement('pre');
                        textContent.style.cssText = 'color: #e2e8f0; margin: 5px 0; white-space: pre-wrap;';
                        textContent.textContent = `\n${JSON.stringify(logData, null, 2)}`;
                        logEntry.appendChild(textContent);
                    }
                } else {
                    const textContent = document.createElement('span');
                    textContent.textContent = `\n${String(logData)}`;
                    logEntry.appendChild(textContent);
                }
                fragment.appendChild(logEntry);
                fragment.appendChild(document.createElement('br'));
                renderedLogIds.add(log.id);
            });

            logContainer.appendChild(fragment);
            lastLogCount = logs.length;

            // Restore exact scroll position
            logContainer.scrollTop = scrollPosition;
        }

        window.toggleTask = (element) => {
            const taskElement = element.closest('.task');
            const taskId = taskElement.getAttribute('data-task-id');
            const content = element.nextElementSibling;

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                expandedTasks.delete(taskId);
            } else {
                content.classList.add('expanded');
                expandedTasks.add(taskId);
            }

            // Show/hide the Run All button when expanding/collapsing
            const runAllButton = content.querySelector('.run-all-subtasks');
            if (runAllButton) {
                if (content.classList.contains('expanded')) {
                    runAllButton.style.display = 'inline-block';
                } else {
                    runAllButton.style.display = 'none';
                }
            }
        }

        window.viewLogs = (runId, displayId) => {
            console.log('Opening log modal for runId:', runId, 'displayId:', displayId);
            logModal.style.display = 'block';
            logModalTitle.textContent = `Logs for: ${displayId || runId}`;
            logLastUpdated.textContent = ''; // Clear timestamp
            logContainer.innerHTML = '<p>Loading logs...</p>';
            lastLogCount = 0; // Reset log count for new task
            renderedLogIds.clear(); // Clear rendered log IDs
            currentLogRunId = runId; // Set current run ID

            // Initial fetch
            fetchTaskLogs(runId);

            // Clear any existing interval
            if (activeTimers.logs) {
                clearInterval(activeTimers.logs);
            }

            // Set up new interval
            activeTimers.logs = setInterval(() => {
                if (currentLogRunId === runId) {
                    console.log('Fetching updated logs for:', runId);
                    fetchTaskLogs(runId);
                }
            }, 2000);
        }

        closeButton.onclick = () => {
            logModal.style.display = 'none';
            logLastUpdated.textContent = ''; // Clear timestamp
            lastLogCount = 0; // Reset log count when closing modal
            renderedLogIds.clear(); // Clear rendered log IDs
            currentLogRunId = null; // Clear current run ID
            if (activeTimers.logs) clearInterval(activeTimers.logs);
            activeTimers.logs = null;
        }

        copyLogsBtn.onclick = async () => {
            try {
                // Extract text content from logs, preserving structure
                let logText = '';
                const logEntries = logContainer.children;

                for (let i = 0; i < logEntries.length; i++) {
                    const entry = logEntries[i];
                    if (entry.tagName === 'DIV') {
                        // Get the text content, handling both simple text and JSON
                        let entryText = '';

                        // Get the header (timestamp and agent type)
                        const strongElements = entry.getElementsByTagName('strong');
                        if (strongElements.length > 0) {
                            entryText += strongElements[0].textContent + '\n';
                        }

                        // Get the content (either JSON or plain text)
                        const textNodes = [];
                        const walker = document.createTreeWalker(
                            entry,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );

                        let node;
                        while (node = walker.nextNode()) {
                            if (node.parentNode.tagName !== 'STRONG') {
                                textNodes.push(node.textContent.trim());
                            }
                        }

                        entryText += textNodes.join('').trim();

                        if (entryText) {
                            logText += entryText + '\n\n';
                        }
                    }
                }

                // Copy to clipboard
                await navigator.clipboard.writeText(logText.trim());

                // Show feedback
                const originalText = copyLogsBtn.textContent;
                copyLogsBtn.textContent = '✅ Copied!';
                copyLogsBtn.style.background = '#10b981';

                setTimeout(() => {
                    copyLogsBtn.textContent = originalText;
                    copyLogsBtn.style.background = '#3b82f6';
                }, 2000);

            } catch (error) {
                console.error('Failed to copy logs:', error);
                copyLogsBtn.textContent = '❌ Failed';
                copyLogsBtn.style.background = '#ef4444';

                setTimeout(() => {
                    copyLogsBtn.textContent = '📋 Copy Logs';
                    copyLogsBtn.style.background = '#3b82f6';
                }, 2000);
            }
        }

        window.onclick = (event) => {
            if (event.target == logModal) {
                closeButton.onclick();
            }
        }

        window.createSubtasks = async (fullstackPlannerRunId) => {
            try {
                setLoading(true);
                const response = await fetch('/create-subtasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fullstack_planner_run_id: fullstackPlannerRunId,
                        skip_existing: true  // Add this flag to skip existing tasks
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to create subtasks');
                }

                const result = await response.json();

                if (result.created_tasks.length > 0) {
                    showAlert(`✅ ${result.message}`);
                    fetchActiveTasks(); // Refresh to show new tasks
                } else {
                    showAlert(`ℹ️ ${result.message}`, 'warning');
                }

            } catch (error) {
                showAlert(`❌ Error creating subtasks: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        window.runAllSubtasks = async (fullstackPlannerRunId) => {
            try {
                setLoading(true);
                // First, we need to get all child tasks that are not running or completed
                const childTasks = activeTasks.filter(task =>
                    task.payload &&
                    task.payload.parent_fullstack_id === fullstackPlannerRunId &&
                    task.payload.agent_status !== 'Running' &&
                    task.payload.agent_status !== 'Completed'
                );

                if (childTasks.length === 0) {
                    showAlert('No subtasks available to run', 'warning');
                    return;
                }

                // For each non-running, non-completed child task, send a request to run it
                const promises = childTasks.map(async (task) => {
                    try {
                        const response = await fetch(`/run-task/${task.task_id}`, {
                            method: 'POST'
                        });

                        if (!response.ok) {
                            const err = await response.json();
                            throw new Error(err.detail || 'Failed to run task');
                        }

                        return await response.json();
                    } catch (error) {
                        console.error(`Failed to run task ${task.task_id}:`, error);
                        return { error: true, task_id: task.task_id };
                    }
                });

                const results = await Promise.all(promises);
                const successCount = results.filter(r => !r.error).length;

                if (successCount > 0) {
                    showAlert(`✅ Started ${successCount} subtasks successfully`);
                    fetchActiveTasks(); // Refresh to show updated status
                } else {
                    showAlert('Failed to start any subtasks', 'error');
                }

            } catch (error) {
                showAlert(`❌ Error running subtasks: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        window.deleteTask = async (taskId, hasChildren) => {
            // Find all direct and nested child tasks
            const getAllChildTasks = (parentId) => {
                const directChildren = activeTasks.filter(task =>
                    task.payload &&
                    (task.payload.parent_run_id === parentId ||
                     task.payload.parent_fullstack_id === parentId)
                );

                let allChildren = [...directChildren];

                // Get children of children recursively
                for (const child of directChildren) {
                    const childId = child.payload.run_id || child.task_id;
                    const nestedChildren = getAllChildTasks(childId);
                    allChildren = [...allChildren, ...nestedChildren];
                }

                return allChildren;
            };

            // Get all child tasks to be deleted
            const childTasks = hasChildren ? getAllChildTasks(taskId) : [];

            try {
                setLoading(true);

                // If task has children, delete them first
                if (childTasks.length > 0) {
                    // Delete each child task, starting from leaf nodes to avoid dependency issues
                    for (const childTask of childTasks.reverse()) {
                        const childId = childTask.payload.run_id || childTask.task_id;
                        try {
                            const response = await fetch(`/active-tasks/${childId}`, {
                                method: 'DELETE'
                            });

                            if (!response.ok) {
                                console.warn(`Failed to delete child task ${childId}: ${response.statusText}`);
                            }
                        } catch (error) {
                            console.error(`Error deleting child task ${childId}:`, error);
                        }
                    }
                }

                // Delete the parent task
                const response = await fetch(`/active-tasks/${taskId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to delete task');
                }

                const result = await response.json();
                if (childTasks.length > 0) {
                    showAlert(`Task ${taskId} and ${childTasks.length} related subtask${childTasks.length > 1 ? 's' : ''} deleted successfully`);
                } else {
                    showAlert(result.message || `Task ${taskId} deleted successfully`);
                }
                fetchActiveTasks(); // Refresh to show updated tasks

            } catch (error) {
                showAlert(`Error deleting task: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        window.toggleRepoSelection = function(element) {
            console.log('Toggle function called');
            const repo = element.getAttribute('data-repo');
            console.log('Repo:', repo);

            const selectedReposInput = document.getElementById('selected-repos');
            const selectedRepos = selectedReposInput.value ? selectedReposInput.value.split(',').filter(r => r) : [];

            console.log('Current selected repos:', selectedRepos);

            if (selectedRepos.includes(repo)) {
                // Remove repo from selection
                selectedReposInput.value = selectedRepos.filter(r => r !== repo).join(',');
                element.style.backgroundColor = '#0D1117';
                element.style.borderColor = '#30363d';
                element.style.color = '#c9d1d9';
                console.log('Deselected repo:', repo);
            } else {
                // Add repo to selection
                selectedReposInput.value = [...selectedRepos, repo].join(',');
                element.style.backgroundColor = '#30363d';
                element.style.borderColor = '#8b949e';
                element.style.color = '#f0f6fc';
                console.log('Selected repo:', repo);
            }

            console.log('Updated selected repos:', selectedReposInput.value);
        };

        // Add new function to handle single subtask creation
        window.createSingleSubtask = async (fullstackPlannerRunId, subtaskIndex) => {
            try {
                setLoading(true);
                const response = await fetch('/create-subtasks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        fullstack_planner_run_id: fullstackPlannerRunId,
                        subtask_index: subtaskIndex
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || 'Failed to create subtask');
                }

                const result = await response.json();

                if (result.created_tasks.length > 0) {
                    showAlert(`✅ ${result.message}`);
                    fetchActiveTasks(); // Refresh to show new task
                } else {
                    showAlert(`ℹ️ ${result.message}`, 'warning');
                }

            } catch (error) {
                showAlert(`❌ Error creating subtask: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        async function init() {
            try {
                setLoading(true);
                await fetchConfig();

                await fetchActiveTasks();
                await fetchDebugMessages();

                if (activeTimers.tasks) clearInterval(activeTimers.tasks);
                if (activeTimers.debug) clearInterval(activeTimers.debug);

                activeTimers.tasks = setInterval(fetchActiveTasks, 2000);
                activeTimers.debug = setInterval(fetchDebugMessages, 5000);

            } catch (error) {
                showAlert(`Initialization failed: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }

        // Use window.onload to ensure all resources are loaded
        window.onload = init;

    </script>
</body>
</html>
